\chapter{Implementácia}

\section{Zmeny súborového systému}
\paragraph{}
Základom našej aplikácie je .NET trieda FileSystemWatcher, ktorú na začiatku inicializujeme a nastavíme na počúvanie události na všetkých pevných diskoch počítaču, ukážka kódu v kóde \ref{lst:init}. Táto trieda generuje události na ktoré reaguje zvyšok programu, existujú dve kategórie událostí na ktoré treba reagovať. Zmena súboru, ktorá zahrňuje vytvorenie, zmenu a zmazanie súboru. Druhá kategória je premenovanie súboru, ktoré sa uskotoční iba pri zmene názvu súboru. Trieda FileSystemWatcher spĺňa takmer všetky naše požiadávky, avšak nevie rozpoznať, ktorý proces stojí za vytvorením daného súboru, čo spôsobuje problém, že môžu byť odchytené události zmien v súboroch od iných procesov ako je naša sledovaná inštalácia, bežne totiž v operačnom systéme beží mnoho programov na pozadí, ktoré si vytvárajú a upravujú súbory. 

\paragraph{Zmena súboru}
Pri tomto type událostí najprv zistíme, ktorá z troch vecí nastala. Pri vytvorení súboru si zapíšeme miesto kde bol tento súbor vytvorený do zoznamu súborov tohto balíku. Túto informáciu využijeme neskôr pri koprírovaní súborov do balíku a inštalácií balíku. Ak bola táto událosť zavolaná pri zmene súboru, skontrolujeme či už tento súbor v tomto balíku monitorujeme, ak nie tak si ho zapíšeme do zoznamu akoby bol novo vytvorený aby sme odzalohovali zmeny, ktoré v ňom nastali. Nakoniec ak táto událosť nastala pri zmazaní súboru, zistíme jeho výskyt v doterajšom zozname súborov a prípadne ho vymažeme aby sme sa neskôr vyhli chybe pri kopírovaní neexistujúceho súboru. Zoznam doteraz monitorovaných súborov si pamätáme v hašovacej mape, keďže nám poskytuje rýchle riešenie vyhľadávania a kontroly prítomnosti prvku v poli.

\paragraph{Premenovanie súboru}
Pri tomto type události prejdeme náš doterajši zoznam nájdeme pôvodný názov a vymažeme ho, zároveň pridáme do zoznamu nový záznam s novým menom súboru. Tento zložitý postup je zapričinený použitím hašovacej mapy, ktorej hašovacia funkcia dostane ako vstup cestu k súboru a preto haš pre starý a nový názov sú odlišné.

\begin{listing}
\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               frame=block,
               framesep=2mm]{csharp}
DriveInfo[] allDrives = DriveInfo.GetDrives();
foreach (DriveInfo d in allDrives)
{
    if (d.DriveType == DriveType.Fixed) 
    { 
        FileSystemWatcher watcher = new FileSystemWatcher();
        watcher.Path = d.Name;
        watcher.IncludeSubdirectories = true;
        watcher.NotifyFilter = NotifyFilters.LastWrite
           | NotifyFilters.FileName | NotifyFilters.DirectoryName;

        watcher.Changed += new FileSystemEventHandler(OnChanged);
        watcher.Created += new FileSystemEventHandler(OnChanged);
        watcher.Deleted += new FileSystemEventHandler(OnChanged);
        watcher.Renamed += new RenamedEventHandler(OnRenamed);

        watcher.EnableRaisingEvents = true;
        watchers.Add(watcher);
    }
}         
\end{minted}
\caption{Inicializácia}
\label{lst:init}
\end{listing}

\section{Rozdiel registrov}
\paragraph{}
K hodnotám registrov, ktoré program vytvoril alebo zmenil sa dostaneme pomocou vytvorenia rozdielu pôvodných registrov a registrov po nainštalovaní programu. K tomuto použijeme algoritmus na nájdenie najdlhšej spoločnej sekvencie, tento algoritmus nebudeme implementovať ale použijeme implementáciu **referencia**. Tento kus kódu dostane na vstup 2 textové súbory a vráti nám riadky v ktorých sa odlišujú. Ako vstup mu teda dodáme výpisy registrov v štandardnom formáte vytvorené pomocou program regedit. Ako výstup dostane výpis nových kľúčov a ich hodnôt vo formáte, ktorý program regedit dokáže prečítať a vytvoriť dané kľúče v registroch. Problém avšak vzniká ak inštalácia zmení hodnotu už vytvoreného kľúča, pretože algoritmus rozpozná zmenu len na riadku priamo s novom hodnotou a nie definíciou kľúča, ktorá bude vtedy identická s tou pred inštaláciou. Tento problém budeme musieť neskôr odstrániť, zatiaľ ho však odignorujeme, vzhľadom na to, že podľa prieskumu nie mnoho programov upravuje počas inštalácie predtým vytvorené registre.

\section{Inštalácia balíčkov}
\paragraph{}

Na každej podstanici bude bežať druhá časť našej aplikácie, ktorá ma za úlohu nastaviť potrebné cesty do registrov, udržovať aktuálny zoznam balíčkov zo serveru a nainštalovať alebo spustiť vyžiadaný balíček. Vrámci inštalácia, aplikácia prejde cez zoznam súborov, ktoré daný balíček obsahuje a skontroluje či existujú na miestách kde majú, ak zistí že neexistuje tak ho tam nakopíruje z balíku. Táto časť aplikácia bere pri spustení 0, 1 alebo 2 parametre. Všetky odkazy vytvorené našou aplikáciou budú smerovať na tento spustiteľný súbor a budú mať aplikáciou nastavené potrebné parametre k spusteniu.

\subsection{0 parametrov}
Pri spustení aplikácie bez parametrov, aplikácia skontroluje Windows Registry a zistí, či obsahujú všetky potrebné údaje pre aplikáciu (cesty k dôležitým zložkám) a následne stiahne zo serveru najnovší zoznam balíčkov a podľa neho vytvorí potrebné odkazy. Odkazy vytvorí na jednom z dvoch miest.
\begin{itemize}
\item Balíčky, ktoré sa spustia pri spustení systému, odkazy budú umiestnené do windows zložky Po spustení
\item Balíčky, ktoré sa spustia na vyžiadanie uživateľa, odkazy budú umiestnené do zložky zapísanej v registroch
\end{itemize}

\subsection{1 parameter}
Ak do aplikácia zadáme len jeden parameter, tento parameter musí byť názov existujúceho balíčku, ktorý aplikácia stiahne zo server a nainštaluje.

\subsection{2 parametre}
Pri dvoch parametroch aplikácia dostane prvý parameter názov balíčku, ktorý ma nainštalovať a ako druhý parameter očakáva cestu k súboru, ktorý ma spustiť po dokončení inštalácie.